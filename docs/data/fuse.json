{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Root","n":1},"1":{"v":"# Welcome to Dendron\n\nThis is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top.\n\n## Lookup\n\nThis section contains useful links to related resources.\n\n- [Getting Started Guide](https://link.dendron.so/6b25)\n- [Discord](https://link.dendron.so/6b23)\n- [Home Page](https://wiki.dendron.so/)\n- [Github](https://link.dendron.so/6b24)\n- [Developer Docs](https://docs.dendron.so/)\n","n":0.132}}},{"i":2,"$":{"0":{"v":"Meet","n":1}}},{"i":3,"$":{"0":{"v":"2023","n":1}}},{"i":4,"$":{"0":{"v":"01","n":1}}},{"i":5,"$":{"0":{"v":"01","n":1},"1":{"v":"_Edit the [[templates.meet]] note to change this template generated for Dendron Meeting Notes._\n\n## Attendees\n\n<!-- Meeting attendees. If you prefix users with an '@', you can then optionally click Ctrl+Enter to create a note for that user. -->\n\n- @john-doe\n\n## Goals\n\n<!-- Main objectives of the meeting -->\n\n## Agenda\n\n<!-- Agenda to be covered in the meeting -->\n\n## Minutes\n\n<!-- Notes of discussion occurring during the meeting -->\n\n## Action Items\n\n<!-- You can add any follow up items here. If they require more detail, you can use `Create Task Note` to create each follow up item as a separate note. -->\n\n- Follow Up Task 1\n- Follow Up Task 2\n","n":0.099}}},{"i":6,"$":{"0":{"v":"Self","n":1}}},{"i":7,"$":{"0":{"v":"Grace","n":1}}},{"i":8,"$":{"0":{"v":"Habit","n":1}}},{"i":9,"$":{"0":{"v":"Some Habit","n":0.707},"1":{"v":"\n### Code\n\n1. 学会表达\n   > 复杂的表达式，把表达式换成变量表示，别人才能语义化理解这个表达式。\n2. 学会复盘\n   > 优秀的程序员会花事件来清理 🆑 自己的代码\n   > 整洁好看的代码比杂乱无章的代码更容易修改，一开始无法写出整洁的代码\n3. 变量提升\n   > 函数会首先提升然后才会到变量\n   > let const 不会变量提升\n4. 防抖\n   > 一段事件只执行一次\n","n":0.213}}},{"i":10,"$":{"0":{"v":"Reading","n":1}}},{"i":11,"$":{"0":{"v":"Book","n":1}}},{"i":12,"$":{"0":{"v":"番茄工作法","n":1},"1":{"v":"\n# 🍅 番茄工作法\n\n### 🖌️ 记录 ✅ 处理 😶‍🌫️ 可视化\n\n### 🖌️ 五个阶段\n\n| 活动   | 事件     | 内容                                         |\n| ------ | -------- | -------------------------------------------- |\n| 规划   | 一天开始 | 决定一天的活动                               |\n| 跟踪   | 全天     | 收集原始数据，一天所花费的功夫和其他相关指标 |\n| 记录   | 一天结束 | 将一天所得的数据整理成档案                   |\n| 处理   | 一天结束 | 将原始数据转化成信息                         |\n| 可视化 | 一天结束 | 处理信息，让它帮助我们明白改善的方法         |\n\n### 🖌️ 需要做的\n\n1. 定时器\n2. 代办任务\n   a. 抬头，时间，地点，作者\n   b. 按照优先顺序排列的待完成的事件列表\n   ⅰ. 计划外和紧急活动。计划外但不得不处理的事件。\n   c. 活动清单\n   d. 记录表：日期，任务描述，完成每一项需要的番茄工作数。\n3. 一天开始从活动清单挑出想完成的任务，然后排出优先级，做成“今日待办事项”\n\n### 🍅 番茄时钟\n\n1. 番茄时钟不能被中断，番茄时钟被打断，从头开始。\n   a. 休息的时候不进行大量的脑力活动，需要的话放到活动清单里面。\n2. 每 4 个番茄为一组\n   a. 简单的休息，呼吸联系，四周走一走，不要做复杂的事情。\n3. 如果任务完成，但是番茄事件还没结束，一个番茄时间必须有始有终，利用时间超量学习，复盘回顾。\n   a. 番茄开始的 5 分钟内完成，可以作为一个例外。\n4. 记录日期，起始时间，活动类型，活动内容，所用番茄数量，达成目标的简述；重要的是每项活动所花费的番茄时钟。\n\n### 🛫 减少干扰\n\n1. 内生干扰\n   1. 干扰可视化，出现干扰，进行记录\n      1. 决定干扰的处理方法\n      2. 新任务紧急且无法推后，在今日“计划外&紧急”出标记\n      3. 记录在活动清单上，标注“U”计划外，如果有必要，可以设定完成该任务的截止时间\n2. 计划外&紧急过多\n   1. 移动到活动清单，明天做\n   2. 在较长的休息时间段处理\n   3. 删除\n3. 计划外&紧急 及需要做\n   1. 干扰活动放到下一个番茄时间，取代原来的活动\n   2. 重新安排时间表\n   3. 将正在进行中的番茄时间作废\n4. 外在干扰，用-表示\n   a. 25 分钟后回复它\n5. 干扰可视化\n   a. 做决定处理干扰\n   ⅰ. 必须当天完成 “计划外&紧急”\n   ⅱ. 活动清单 标注计划外“U”\n   ⅲ. 加强完成番茄时间的意志力\n6. 一个番茄时间不可分割\n7. 意识到外在干扰的次数和类型，根据紧急程序去协商和重新安排他们\n8. 5-6 个番茄时钟；活动过于复杂，需要进行分解；活动预计所花时间不够一个番茄时钟，把类似活动累积起来。\n9. 可用的番茄时间；一天的可用番茄时间；\n   a. 番茄和预测差距较大：继续工作或者进行下一项工作，并进行记录。\n\n### 🖌️ 番茄时间结构\n\n1. 前 3-5 分钟简单重温\n2. 最后几分钟复习之前完成的任务。\n   a. 检查质量方法，需要额外安排 1 到 2 个番茄时钟来做\n\n### 💖 优化你的时间\n\n1. 工作日包含几个番茄时钟；用来工作的番茄时钟和用来学习的番茄时钟。\n2. 对番茄时钟进行规划\n\n### ⭐ 重复和回顾\n\n1. 累的时候少安排点番茄时钟\n2. 落后的多，更需要进行回顾\n\n### 🛫 一些法则\n\n1. 一个番茄时间包括 25 分钟的工作时间和 5 分钟的休息时间。\n2. 每完成 4 个番茄时间，休息 15 到 30 分钟。\n3. 一个番茄时间不可分割。没有所谓的半个番茄时间或四分之一个番茄时间。\n4. 一个番茄时间必须有始有终。\n5. 如果一个番茄时间被不停中断，则该番茄时间作废。\n6. 如果在一个番茄时间没结束就完成了任务，请检查、回顾任务，直到定时器响起。\n7. 保护番茄工作法。及时告知对方（你目前没有时间），迅速协商、重新安排中断事件并按照协商时间回复来找你的人。\n8. 如果任务预计要花超过 5 到 7 个番茄工作时间，将它分解开来。将复杂的任务分解成几个小任务。\n9. 如果任务预计所花时间不够一个番茄工作时间，把它们累积起来。\n10. 结果是一个又一个番茄时间的累积。\n11. 时间表总是优先于番茄工作时间。\n12. 下一个番茄时间会更顺利\n","n":0.075}}},{"i":13,"$":{"0":{"v":"Grace","n":1},"1":{"v":"\n## 🧘 冥想\n\n### 第一天\n\n1. 注意力放在对象（呼吸）上\n   1. 分心的时候把注意力重新集中在呼吸上\n   2. 感受周围的声音\n   3. 感受自己身体的重量\n","n":0.302}}},{"i":14,"$":{"0":{"v":"Source Code","n":0.707}}},{"i":15,"$":{"0":{"v":"How To Read Source Code","n":0.447},"1":{"v":"\n#Grace #Reading\n\n### Why to read source code\n\n能高效的理解代码是一个程序员的核心能力。刻意的，有目的的去阅读源代码。\n\n- 有目的的阅读代码会帮助程序员更快速的成长\n\n### The ability that must be mastered\n\n1. 高效的使用编辑器，快速搜索关键字、查找变量和函数的相关引用。对编辑器熟练使用（用键盘操作）\n2. 掌握 git 版本控制工具\n3. 大型项目需要了解设计模式\n4. 设计文档，代码约定\n\n### Edge shortcut key\n\n- ctrl+T 新打开标签页（Tag)\n- ctrl+shift+t 打开刚关闭的标签页\n- ctrl+w 关闭当前标签页\n- ctrl+shift+w 关闭所有标签页，退出窗口\n- ctrl+N 创建新窗口\n- ctrl+shift+N 以隐身模式创建新窗口\n- alt+F4 退出窗口\n- ctrl+G 和 ctrl+F 一样，Ctrl+G 可以进行跳转，Enter 是跳转下一个结果，shift+enter 返回上一个结果。\n- [空格]滚动\n- shift+[空格] 向上滚动\n- ctrl+tab 下一个标签元\n- ctrl+shift+tab 上一个页面\n- ctrl+[数字] 打开对应数字的 tab 页面\n\n###\n\n- alt+F4 关闭 windows 窗口\n- alt+[空格] 查看对应快捷键\n- alt+Esc 最小化窗口\n","n":0.126}}},{"i":16,"$":{"0":{"v":"Data Structure","n":0.707}}},{"i":17,"$":{"0":{"v":"Recursion","n":1}}},{"i":18,"$":{"0":{"v":"Recursion","n":1},"1":{"v":"\n### 递归\n\n1. 问题的解可以分为几个子问题的解\n2. 子问题的解除了数据规模不通，求解思路完全一样\n3. 存在递归终止条件。\n\n## 优化\n\n1. 重复计算问题--避免重复计算，通过数据结构（散列表）保存已经求解过的值。\n\n- recursion = 循环\n- frequency = 频率\n\nString 对象不可变，每次使用 String 类中的方法之一，都要在内存中新建字符串对象。若要修改字符串可以使用 StringBuilder\n","n":0.243}}},{"i":19,"$":{"0":{"v":"Stack","n":1},"1":{"v":"\n#Data-Structure #Stack\n\n1. 后进先出，先进后出，操作受限的线性表\n2. 数组实现的栈=顺序栈，链表实现的栈=链式栈\n\n   1. 栈的相关 leetcode 题目：20,155,232,844,224,682,496.\n\n### 相关题目\n\n1. 20 题目描述：有效的括号,给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n```c#\n public class Solution {\n     public bool IsValid(string s) {\n         Stack<char> sc = new Stack<char>();\n         Dictionary<char, char> otherChar = new Dictionary<char, char>() { { '(', ')' }, { '[',']' },{ '{','}'} };\n         foreach( var item in s)\n         {\n             if(otherChar.ContainsKey(item)) sc.Push(item);\n             else\n             {\n                 if (sc.Count == 0) return false;\n                 char c = sc.Pop();\n                 if (otherChar[c] != item) return false;\n             }\n\n         }\n         return sc.Count == 0;\n\n     }\n }\n```\n\n2. 155 题描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\n实现 MinStack 类:\n\n- MinStack() 初始化堆栈对象。\n- void push(int val) 将元素 val 推入堆栈。\n- void pop() 删除堆栈顶部的元素。\n- int top() 获取堆栈顶部的元素。\n- int getMin() 获取堆栈中的最小元素。\n\n```C#\npublic class MinStack {\n\n    private int?[] _array;\n    private int _size = 0;\n\n    private const int _defaultCapacity = 10;\n\n    public MinStack()\n    {\n        _array = new int?[_defaultCapacity];\n    }\n\n    public void Push(int val)\n    {\n        if (_array.Length == _size)\n        {\n            int?[] newArray = new int?[_size * 2];\n            Array.Copy(_array, newArray, _size);\n            _array = newArray;\n        }\n        _array[_size++] = val;\n    }\n\n    public void Pop()\n    {\n        _array[--_size] = null;\n    }\n\n    public int Top()\n    {\n        return (int)_array[_size - 1];\n    }\n\n    public int GetMin()\n    {\n        return (int)_array.Min();\n    }\n}\n```\n\n- 占用内存最小的解法\n\n```C#\npublic class MinStack {\n\n    Stack<int> stack;\n    Stack<int> minStack;\n\n    public MinStack()\n    {\n        stack= new Stack<int>();\n        minStack= new Stack<int>();\n    }\n\n    public void Push(int val)\n    {\n        stack.Push(val);\n        if(minStack.Count == 0 || minStack.Peek() >= val)\n        {\n            minStack.Push(val);\n        }\n    }\n\n    public void Pop()\n    {\n        if(minStack.Count!= 0 && stack.Pop() == minStack.Peek())\n        {\n            minStack.Pop();\n        }\n    }\n\n    public int Top()\n    {\n        return stack.Peek();\n    }\n\n    public int GetMin()\n    {\n        return minStack.Peek();\n    }\n}\n\n```\n\n3. 232 题，用栈实现队列。题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\n- void push(int x) 将元素 x 推到队列的末尾\n- int pop() 从队列的开头移除并返回元素\n- int peek() 返回队列开头的元素\n- boolean empty() 如果队列为空，返回 true ；否则，返回 false\n  说明：\n\n- 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n\n```C#\npublic class MyQueue {\n\n    Stack<int> leftStack;\n    Stack<int> rightStack;\n\n    public MyQueue()\n    {\n        leftStack= new Stack<int>();\n        rightStack= new Stack<int>();\n    }\n\n    public void Push(int x)\n    {\n        if(leftStack.Count==0) leftStack.Push(x);\n        else\n        {\n            while(leftStack.Count != 0)\n            {\n                int v = leftStack.Pop();\n                rightStack.Push(v);\n            }\n            leftStack.Push(x);\n            while(rightStack.Count != 0)\n            {\n                int v = rightStack.Pop();\n                leftStack.Push(v);\n            }\n        }\n\n        //另一种解题思路\n        while(leftStack.Count !=0) rightStack.Push(leftStack.Pop());\n        leftStack.Push(x);\n        while(rightStack.Count != 0) leftStack.Push(rightStack.Pop());\n    }\n\n    public int Pop()\n    {\n        return leftStack.Pop();\n    }\n\n    public int Peek()\n    {\n        return leftStack.Peek();\n    }\n\n    public bool Empty()\n    {\n        return leftStack.Count == 0;\n    }\n}\n```\n\n844 题目：给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n\n注意：如果对空文本输入退格字符，文本继续为空。\n示例 1：\n\n输入：s = \"ab#c\", t = \"ad#c\"\n输出：true\n解释：s 和 t 都会变成 \"ac\"。\n示例 2：\n\n输入：s = \"ab##\", t = \"c#d#\"\n输出：true\n解释：s 和 t 都会变成 \"\"。\n示例 3：\n\n输入：s = \"a#c\", t = \"b\"\n输出：false\n解释：s 会变成 \"c\"，但 t 仍然是 \"b\"。\n\n```C#\npublic class Solution {\n    public bool BackspaceCompare(string s, string t) {\n        Stack<char> l = new Stack<char>();\n        Stack<char> r = new Stack<char>();\n\n        foreach(var item in s)\n        {\n            if(item == '#'){\n                 if(l.Count > 0) l.Pop();\n            }\n            else l.Push(item);\n        }\n        foreach(var item in t)\n        {\n            if (item == '#' ){\n                if(r.Count > 0) r.Pop();\n            }\n            else r.Push(item);\n        }\n        if (l.Count != r.Count) return false;\n        while(l.Count > 0){\n            if(l.Pop() != r.Pop()) return false;\n        }\n        return true ;\n    }\n}\n\n```\n\n题目 682，棒球比赛：你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。\n\n比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：\n\n整数 x - 表示本回合新获得分数 x\n\"+\" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。\n\"D\" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。\n\"C\" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。\n请你返回记录中所有得分的总和。\n\n```c#\npublic int CalPoints(string[] operations) {\n        Stack<int> stack = new Stack<int>();\n        foreach (var s in operations)\n        {\n            if (s == \"+\")\n            {\n                int num1 = stack.Pop();\n                int num2 = stack.Peek();\n                stack.Push(num1);\n                stack.Push(num1 + num2);\n            }\n            else if (s == \"D\")\n            {\n\n                int num1 = stack.Peek();\n                stack.Push(2 * num1);\n            }\n            else if (s == \"C\")\n            {\n\n                stack.Pop();\n            }\n            else stack.Push(int.Parse(s));\n        }\n        int sum = 0;\n        while (stack.Any())\n        {\n            sum += stack.Pop();\n        }\n        return sum;\n    }\n```\n\n题目 496，下一个更大元素：\nnums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。\n\n给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中 nums1 是 nums2 的子集。\n\n对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。\n\n返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。\n\n示例 1：\n\n输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n\n- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n\n```c#\npublic int[] NextGreaterElement(int[] nums1, int[] nums2) {\n        List<int> stack = new List<int>();\n        int n1 = nums1.Length;\n        int n2 = nums2.Length;\n        for (int i = 0; i < n1; i++)\n        {\n            int max = -1;\n            int find = 0;\n            int value = nums1[i];\n\n            for ( int j = 0 ; j < n2; j++)\n            {\n                if (value == nums2[j])\n                {\n                    find = j;\n                    break;\n                };\n            }\n            if (find != n2)\n            {\n                for ( int k = find; k < n2; k++)\n                {\n                    if (value < nums2[k])\n                    {\n                        max = nums2[k];\n                        break;\n                    }\n                }\n            }\n            stack.Add(max);\n        }\n        return stack.ToArray();\n    }\n```\n","n":0.037}}},{"i":20,"$":{"0":{"v":"Queue","n":1},"1":{"v":"\n#Data-Structure #Queue\n\n1. 操作受限的线性表数据结构，先进先出\n   1. 入队 enqueue()\n   2. 出队 dequeue()\n2. 顺序队列和链式队列\n3. 循环队列；确定好队空和队满的判定条件。\n   1. 队满：`(tail+1)%n = head`\n   2. 循环队列会浪费一个数组的存储空间\n   3. `tail = (tail+1)%n`\n   4. `head = (head+1)%n`\n4. 阻塞队列\n   1. 队列为空时，阻塞`dequeue`,直到有数据\n   2. 队列为满时，阻塞`enqueue`,直到队列有空间\n   3. 生产者-消费者模型\n5. 并发队列-线程安全的队列。直接在`enqueue`和`dequeue`方法加锁。\n6. 无界队列`unbounded queue`,无限排队的队列，导致过多的请求排队等待。基于链表。\n7. 相关题目：225，239，347，1047，\n\n题目 225 用队列实现栈：请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\n\n实现 MyStack 类：\n\n- void push(int x) 将元素 x 压入栈顶。\n- int pop() 移除并返回栈顶元素。\n- int top() 返回栈顶元素。\n- boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n```c#\nprivate Queue<int> q1;\n    private Queue<int> q2;\n    public MyStack()\n    {\n        q1 = new Queue<int>();\n        q2 = new Queue<int>();\n    }\n\n    public void Push(int x)\n    {\n        while (q1.Any()) q2.Enqueue(q1.Dequeue());\n        q1.Enqueue(x);\n        while (q2.Any()) q1.Enqueue(q2.Dequeue());\n    }\n\n    public int Pop()\n    {\n        return q1.Dequeue();\n    }\n\n    public int Top()\n    {\n        return q1.Peek();\n    }\n\n    public bool Empty()\n    {\n        return !q1.Any();\n    }\n```\n","n":0.094}}},{"i":21,"$":{"0":{"v":"Templates","n":1}}},{"i":22,"$":{"0":{"v":"Meeting Notes Template","n":0.577},"1":{"v":"_Edit the [[templates.meet]] note to change this template generated for Dendron Meeting Notes._\n\n## Attendees\n\n<!-- Meeting attendees. If you prefix users with an '@', you can then optionally click Ctrl+Enter to create a note for that user. -->\n\n- @john-doe\n\n## Goals\n\n<!-- Main objectives of the meeting -->\n\n## Agenda\n\n<!-- Agenda to be covered in the meeting -->\n\n## Minutes\n\n<!-- Notes of discussion occurring during the meeting -->\n\n## Action Items\n\n<!-- You can add any follow up items here. If they require more detail, you can use `Create Task Note` to create each follow up item as a separate note. -->\n\n- Follow Up Task 1\n- Follow Up Task 2\n","n":0.099}}},{"i":23,"$":{"0":{"v":"Template","n":1}}},{"i":24,"$":{"0":{"v":"Dialy Recheck","n":0.707}}},{"i":25,"$":{"0":{"v":"Dialy Recheck","n":0.707},"1":{"v":"\n#复盘 #记录\n\n### EveryWeek\n\n- [ ] 打开电脑，看代码\n- [ ] 要提升自己的技能呀\n\n### ✅ToDo List\n\n- [ ] 师带徒总结审阅\n- [ ] 人脸识别问题\n- [ ]\n\n### ✊ 做的好的三件事情\n\n### 😣 做的不好的一件事情\n\n1. 早上早点起来\n\n### 🧑‍💻 核心能力`编程思想`的提高\n\n1. 理解滑动窗口思想，现在 2ms 的为投机取巧方法。\n\n### 项目追踪 YHUCPG\n\n1. JavaScript 对象的使用，原型，\n2. C#和 JavaScript 中相关函数的区别\n3.\n","n":0.167}}},{"i":26,"$":{"0":{"v":"Project","n":1}}},{"i":27,"$":{"0":{"v":"Zxauto","n":1}}},{"i":28,"$":{"0":{"v":"Zn","n":1}}},{"i":29,"$":{"0":{"v":"Grace","n":1}}},{"i":30,"$":{"0":{"v":"项目上使用功能","n":1},"1":{"v":"\n1. 拷贝数据库 `robocopy D:\\mgbak \\\\192.168.9.3\\d$\\msbak\\mongo /MIR`\n2. 准能 wifi 用户名 20009646 密码 Lc123456\n","n":0.289}}},{"i":31,"$":{"0":{"v":"项目基本情况","n":1},"1":{"v":"\n#Project\n\n### 单位联络\n\n### 190 服务器\n\n1. 现场负责人：李英杰 -- 13213841732\n2. 地址段\n   1. 169.254.24.190\n   2. 192.168.100.72\n   3. 172.1.1.80\n\n#### 大连理工\n\n1. 现场负责人：潘志宝 -- 18842519233\n2. 服务器\n   1. 169.254.24.194\n   2. 192.168.100.89\n   3. 172.1.1.89\n   4. 172.28.160.1\n   5. 用户名：zxauto，密码：dl.123!!!\n   6. 超融合服务器：\n      1. 安全管理： 172.16.34.9\n      2. 生产管理： 172.16.34.11\n","n":0.164}}},{"i":32,"$":{"0":{"v":"Dendron","n":1}}},{"i":33,"$":{"0":{"v":"开始","n":1}}},{"i":34,"$":{"0":{"v":"记笔记","n":1},"1":{"v":"\n# 开始写作之旅\n\n## 快速开始栏\n\n你可以使用快速开始栏和 Dendron 进行交互。快速开始栏可以用来查找笔记和创建笔记。使用`Dendron: Lookup`(快捷键`Ctrl+L/Cmd+L`)打开快速开始栏。\n![快速开始栏](https://org-dendron-public-assets.s3.amazonaws.com/images/tutorial-lookup.gif)\n\n## 创建笔记\n\n在 Dendron 创建笔记的步骤如下：\n\n1. 使用快捷键`Ctrl+L/Cmd+L`打开快速开始栏；\n2. 在快速开始栏中输入笔记名（例如：recipes);\n3. 点击`Create New`;\n4. 按下`Enter`键，名字为 recipes.md 的笔记就创建好了。您可以在里面添加内容。\n\n   > 🎗️ 小提示：使用快捷键`Ctrl+Tab/Cmd+Tab`来在编辑的笔记之间的快速跳转。  \n   > 📝 信息：笔记是 markdown 文件，请注意\n   >\n   > > 1. 笔记存储在本地\n   > > 2. 笔记可以跨操作系统，软件\n   > > 3. 让您的笔记快速导入导出，查看[发布笔记到网站上](https://wiki.dendron.so/notes/4ushYTDoX0TYQ1FDtGQSg)\n\n   - [test](daily.journal.2022.12.05.md)\n","n":0.158}}},{"i":35,"$":{"0":{"v":"UI布局","n":1},"1":{"v":"\n# 页面布局\n\n来一起看一下 Dendron 用户界面（工作台）长什么样子吧\n\n> 🎗️ 小提示：如果你对 VS Code 还不太了解，接下来将介绍关于 VS Code 的基本知识。需要快速执行命令时（包括 Dendron 命令）需要用到命令面板。使用快捷键`Ctrl+Shift+P/Cmd+Shift+P`打开命令面板并输入命令，按回车键执行。如果你在接下来的指南中看到运行一个命令，请打开命令面板输入命令并执行。\n\n![Decdeon UI](https://org-dendron-public-assets.s3.amazonaws.com/images/tutorial-layout-2-dark.png)\n\n> 🎗️ 小提示：VS Code 允许你重新设计这些窗口，您可以自由组合成最适应您的 Dendron UI 布局。详情查看[VS Code documentation for more information on the VS Code UI](https://code.visualstudio.com/docs/getstarted/userinterface)\n\n### 1. 编辑区域\n\n在这里可以编辑您的笔记，在 Dendron 中笔记时[Markdown](https://wiki.dendron.so/notes/ba97866b-889f-4ac6-86e7-bb2d97f6e376/)文件(my.note.md)。\n\n### 2. 预览界面\n\n显示当前笔记的预览界面。你可以使用命令`Dendron: Toggle Preview`来打开和关闭预览界面。  \n在预览界面的最下面您可以看到[孩子]和[连接]两个部分，这部分内容在接下来的介绍。\n\n> 🎗️ 小提示：预览界面是只读的，请在编辑区域进行文档编辑。\n\n### 3. 文件资源管理器\n\n此页面显示您的文件和文件夹，保存着您的笔记和资源（图片，pdfs 等）。\n\n> 🎗️ 小提示：我们推荐您使用[树导航](https://wiki.dendron.so/notes/gHdxXlNMr1w4xqee0n-Mb/#6.树导航视图)来导航你的笔记文件。\n\n### 4.大纲窗口\n\n显示当前笔记的标题大纲，通过点击大纲来跳转到制定区域。\n\n### 5.日历窗口\n\n每天记录的快捷入口，如果所选时间不存在一个记录，将会自动创建记录。\n![自动创建记录](https://org-dendron-public-assets.s3.amazonaws.com/images/create-daily-journal-calendar.gif)\n\n### 6.树导航视图\n\n这里显示笔记的分级视图，类似于文件夹结构在文件系统中的显示方式，点击就可以快速浏览笔记。\n![树导航](https://org-dendron-public-assets.s3.amazonaws.com/images/tutorial-tree-view-dark.png)\n\n### 7.外链导航窗口\n\n显示编辑窗笔记所有的外链。\n[导航窗口](https://org-dendron-public-assets.s3.amazonaws.com/images/tutorial-backlinks-dark.png)\n\n### 继续探索吧\n\n- 下一步：尝试写作吧\n","n":0.136}}},{"i":36,"$":{"0":{"v":"初见","n":1},"1":{"v":"\n# 让我们开启 Dendron 之旅吧\n\n### 准备工作\n\n本指南将帮助您了解 Dendron 的基本知识。在开始之前，请确保您做了以下工作：\n\n- 安装了 [VS Code](https://code.visualstudio.com/download)或者和 VS Code 类似的编译器，例如：[VSCodium](https://vscodium.com/)\n- 在插件市场安装[Dendron](https://link.dendron.so/vscode)\n\n### 初始化工作空间\n\n> 工作空间是一个或多个知识库，是一个文件夹，里面是所有管理你 Dendron 所必须的文件。\n\n当你安装 Dendron,你将看到下面的界面。点击开始按钮后就会初始化一个工作空间。\n![开始页面](https://org-dendron-public-assets.s3.amazonaws.com/images/tutorial-welcome-screen-2.png)\n\n> 🎗️ 小提示：当你找不到欢迎界面时，你可以通过快捷键`Ctrl+shift+p / Cmd+Shift+P`打开命令面板，然后输入命令 `Dendron: Launch Tutorial to create a workspace`  \n> ![打开欢迎界面](https://org-dendron-public-assets.s3.amazonaws.com/images/tutorial-launch-tutorial-cmd-2.gif)\n\n### 开始新的旅程吧\n\n1.\n","n":0.174}}},{"i":37,"$":{"0":{"v":"2022-12-05复盘","n":1},"1":{"v":"\n#复盘 #记录\n\n### ✅ToDo List\n\n- [ ]\n- [x]\n\n### ✊ 做的好的三件事情\n\n1. 晚上又好好的看数据结构呀，遇到了不同的解题思路很开心呀。\n\n### 😣 做的不好的一件事情\n\n1. 早上可以稍微早点起来呀\n\n### 🧑‍💻 核心能力`编程思想`的提高\n\n1. 滑动窗口取最大值的思想，依次滑动，只记录最大值，一遍过。\n","n":0.25}}},{"i":38,"$":{"0":{"v":"Journal","n":1}}},{"i":39,"$":{"0":{"v":"2022","n":1}}},{"i":40,"$":{"0":{"v":"12","n":1}}},{"i":41,"$":{"0":{"v":"2022-12-28 复盘","n":0.707},"1":{"v":"\n### 📒 笔记过程\n\n1. 冥想 ![[self.reading.grace]]\n2. 番茄工作法\n   1. 番茄工作法时钟结构 ![[self.reading.book.TomatoWorkingMethod #️-番茄时间结构]]\n   2. 如何处理干扰\n      1. 内在干扰，清单记录 计划外&紧急\n   3. 一些法则 [[self.reading.book.TomatoWorkingMethod #-一些法则]]\n   4. 时间优化\n\n### 😶‍🌫️ 讶羽的博客\n\n1. 什么是学习？\n","n":0.204}}},{"i":42,"$":{"0":{"v":"2022-12-15","n":1}}},{"i":43,"$":{"0":{"v":"2022-12-14 复盘","n":0.707},"1":{"v":"\n#复盘 #记录\n\n### EveryWeek\n\n- [ ] 打开电脑，看代码\n- [ ] 要提升自己的技能呀\n\n### ✅ToDo List\n\n- [ ] 师带徒总结审阅\n- [ ] 人脸识别问题\n- [ ]\n\n### ✊ 做的好的三件事情\n\n### 😣 做的不好的一件事情\n\n1. 早上早点起来\n\n### 🧑‍💻 核心能力`编程思想`的提高\n\n1. 理解滑动窗口思想，现在 2ms 的为投机取巧方法。\n\n### 项目追踪 YHUCPG\n\n1. JavaScript 对象的使用，原型，\n2. C#和 JavaScript 中相关函数的区别\n3.\n\n### Some Truth\n\n1. 一旦你出现明天开始努力的想法，而不是从现在开始，那你明天大概率还是虚度光阴。\n   > 日复一日，抓住出现想法的那一刻\n2. 你没必要和别人杠，由于知识的贫穷，他只能活在自己的世界里，只人自己的那个想法，你很难改变他。\n3. 真正要做的事，对神明都不要讲\n4. 人所有的拖沓，都是代表他并非真正的热爱。\n5. 知识越贫乏，你所相信的东西就越绝对，因为你根本没有思考过与此相对立的观点。\n6. 今早雾霾蔽日，但是不要害怕，太阳依旧在云端。\n7. 真正让你成长的，永远时那些让你害怕、逃避、疼痛的事情。\n\n多借口访问（数据静态，动态接口），摄像头，控制信号，仓储配煤--，数据量比较大，\n-- 静态，plc,动态数据，摄像头下\n-- 控制信号 -- 控制信号访问，\n-- 仓储配煤 -- 提供文档\n","n":0.136}}},{"i":44,"$":{"0":{"v":"2022-12-13 复盘","n":0.707},"1":{"v":"\n#复盘 #记录\n\n### EveryWeek\n\n- [x] 打开电脑，看代码\n\n### ✅ToDo List\n\n- [ ] 完成 LeetCode 滑动窗口 239 题\n- [x] 师带徒总结\n\n### ✊ 做的好的三件事情\n\n### 😣 做的不好的一件事情\n\n1. 早上早点起来\n\n### 🧑‍💻 核心能力`编程思想`的提高\n\n1. 理解滑动窗口思想，现在 2ms 的为投机取巧方法。\n\n### 项目追踪 YHUCPG\n\n1. JavaScript 对象的使用，原型，\n2. C#和 JavaScript 中相关函数的区别\n3.\n\n### Some Truth\n\n1. 一旦你出现明天开始努力的想法，而不是从现在开始，那你明天大概率还是虚度光阴。\n   > 日复一日，抓住出现想法的那一刻\n2. 你没必要和别人杠，由于知识的贫穷，他只能活在自己的世界里，只人自己的那个想法，你很难改变他。\n3. 真正要做的事，对神明都不要讲\n4. 人所有的拖沓，都是代表他并非真正的热爱。\n5. 知识越贫乏，你所相信的东西就越绝对，因为你根本没有思考过与此相对立的观点。\n6. 今早雾霾蔽日，但是不要害怕，太阳依旧在云端。\n7. 真正让你成长的，永远时那些让你害怕、逃避、疼痛的事情。\n","n":0.151}}},{"i":45,"$":{"0":{"v":"2022-12-12","n":1},"1":{"v":"\n#复盘 #记录\n\n### EveryWeek\n\n- [ ] 打开电脑，看代码\n\n### ✅ToDo List\n\n- [ ] 完成 LeetCode 滑动窗口 239 题\n- [ ] 年终总结\n- [ ] 师带徒总结\n- [ ] 完成试运行方案\n\n### ✊ 做的好的三件事情\n\n1.\n\n### 😣 做的不好的一件事情\n\n1. 早上早点起来\n\n### 🧑‍💻 核心能力`编程思想`的提高\n\n1. 理解滑动窗口思想，现在 2ms 的为投机取巧方法。\n","n":0.171}}},{"i":46,"$":{"0":{"v":"2022-12-08","n":1},"1":{"v":"\n#复盘 #记录\n\n### ✅ToDo List\n\n- [ ] 完成 LeetCode 滑动窗口 239 题\n- [ ] 早上起来后看一天要做的事情\n- [ ] 完成总结\n\n### ✊ 做的好的三件事情\n\n1.\n\n### 😣 做的不好的一件事情\n\n1. 早上早点起来\n\n### 🧑‍💻 核心能力`编程思想`的提高\n\n1. 理解滑动窗口思想，现在 2ms 的为投机取巧方法。\n","n":0.192}}},{"i":47,"$":{"0":{"v":"2022-12-07 记录","n":0.707},"1":{"v":"\n#复盘 #记录\n\n### ✅ToDo List\n\n- [ ] 完成 LeetCode 滑动窗口 239 题\n- [ ] 看一会意志力红利\n- [ ] 看一会诗歌之类的书\n\n### ✊ 做的好的三件事情\n\n1.\n\n### 😣 做的不好的一件事情\n\n1. 早上早点起来\n\n### 🧑‍💻 核心能力`编程思想`的提高\n\n1. 理解滑动窗口思想，现在 2ms 的为投机取巧方法。\n","n":0.192}}},{"i":48,"$":{"0":{"v":"2022-12-06 复盘","n":0.707},"1":{"v":"\n#复盘 #记录\n\n### ✅ToDo List\n\n- [x] 完成 LeetCode 滑动窗口 239 题\n- [ ] 看一会意志力红利\n- [ ] 看一会诗歌之类的书\n\n### ✊ 做的好的三件事情\n\n1.\n\n### 😣 做的不好的一件事情\n\n1. 早上早点起来\n\n### 🧑‍💻 核心能力`编程思想`的提高\n\n1. 理解滑动窗口思想，现在 2ms 的为投机取巧方法。\n","n":0.196}}},{"i":49,"$":{"0":{"v":"2022-12-05 复盘","n":0.707},"1":{"v":"\n#复盘 #记录\n\n### ✅ToDo List\n\n- [ ]\n- [x]\n\n### ✊ 做的好的三件事情\n\n1. 晚上又好好的看数据结构呀，遇到了不同的解题思路很开心呀。\n\n### 😣 做的不好的一件事情\n\n1. 早上可以稍微早点起来呀\n\n### 🧑‍💻 核心能力`编程思想`的提高\n\n1. 滑动窗口取最大值的思想，依次滑动，只记录最大值，一遍过。\n","n":0.25}}}]}
